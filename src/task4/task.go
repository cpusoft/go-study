package task

import (
	"context"
	"fmt"
	"runtime/debug"
	"sync"
	"time"
)

// ========== æ ¸å¿ƒæšä¸¾å®šä¹‰ ==========
type TaskState string

const (
	TaskStatePending   TaskState = "pending"
	TaskStateRunning   TaskState = "running"
	TaskStateCompleted TaskState = "completed"
)

type TaskResult string

const (
	TaskResultOK   TaskResult = "ok"
	TaskResultFail TaskResult = "fail"
)

type AddTaskMode int

const (
	AddTaskModeRecursive AddTaskMode = 1 // é€’å½’æ¨¡å¼ï¼šä»æˆåŠŸä»»åŠ¡ç”Ÿæˆæ–°ä»»åŠ¡å¹¶ç«‹å³æ‰§è¡Œ
	AddTaskModeExternal  AddTaskMode = 2 // å¤–éƒ¨æ¨¡å¼ï¼šå¤–éƒ¨æ³¨å…¥ä»»åŠ¡ï¼Œå¾…ä¸‹å‘¨æœŸæ‰§è¡Œ
)

// ========== é…ç½®ç»“æ„ä½“å®šä¹‰ ==========
type Config struct {
	Mode          AddTaskMode   // ä»»åŠ¡æ·»åŠ æ¨¡å¼ï¼ˆå¿…å¡«ï¼‰
	CycleInterval time.Duration // å‘¨æœŸé—´éš”ï¼ˆé»˜è®¤30åˆ†é’Ÿï¼‰
	CheckInterval time.Duration // å‘¨æœŸå†…æ£€æŸ¥é—´éš”ï¼ˆé»˜è®¤10åˆ†é’Ÿï¼‰
	MaxTimeout    time.Duration // æœ€é•¿æ‰§è¡Œè¶…æ—¶ï¼ˆé»˜è®¤70åˆ†é’Ÿï¼‰
	MaxConcurrent int           // æœ€å¤§å¹¶å‘æ‰§è¡Œä»»åŠ¡æ•°ï¼ˆé»˜è®¤100ï¼‰
}

func NewConfig(mode AddTaskMode) *Config {
	return &Config{
		Mode:          mode,
		CycleInterval: 30 * time.Minute,
		CheckInterval: 10 * time.Minute,
		MaxTimeout:    70 * time.Minute,
		MaxConcurrent: 100,
	}
}

// ========== ä»»åŠ¡ç»“æ„ä½“å®šä¹‰ ==========
type TaskData struct {
	Content string
	Params  map[string]interface{}
}

type Task struct {
	Key          string
	Data         TaskData
	State        TaskState
	Result       TaskResult
	SuccessTime  *time.Time
	FailTime     *time.Time
	FailReason   string
	SuccessCount uint64
	FailCount    uint64
	StartTime    *time.Time
	executeFunc  func(ctx context.Context, task *Task) (bool, error)
}

type GenerateTasksFunc func(completedTask *Task) []*Task

// ========== æ¡†æ¶æ ¸å¿ƒç»“æ„ä½“ ==========
type TaskFramework struct {
	tasksMu        sync.RWMutex
	tasks          map[string]*Task
	pendingTasks   map[string]struct{}
	completedTasks map[string]struct{}

	forbiddenMu   sync.RWMutex
	forbiddenKeys map[string]struct{}

	configMu          sync.RWMutex
	config            *Config
	generateMu        sync.RWMutex
	generateTasksFunc GenerateTasksFunc

	cycleMu           sync.RWMutex
	currentCycleStart time.Time
	executorCtx       context.Context
	executorCancel    context.CancelFunc
	wg                sync.WaitGroup
	semaphore         chan struct{}
}

// ========== NewTaskFramework ==========
func NewTaskFramework(ctx context.Context, config *Config) *TaskFramework {
	if config == nil {
		panic("config cannot be nil")
	}
	if config.Mode != AddTaskModeRecursive && config.Mode != AddTaskModeExternal {
		panic("invalid add task mode")
	}
	if config.CycleInterval <= 0 {
		config.CycleInterval = 30 * time.Minute
	}
	if config.CheckInterval <= 0 {
		config.CheckInterval = 10 * time.Minute
	}
	if config.MaxTimeout <= 0 {
		config.MaxTimeout = 70 * time.Minute
	}
	if config.MaxConcurrent <= 0 {
		config.MaxConcurrent = 100
	}
	if config.CheckInterval >= config.CycleInterval {
		panic("check interval must be less than cycle interval")
	}

	executorCtx, executorCancel := context.WithCancel(context.Background())

	return &TaskFramework{
		tasks:          make(map[string]*Task),
		pendingTasks:   make(map[string]struct{}),
		completedTasks: make(map[string]struct{}),
		forbiddenKeys:  make(map[string]struct{}),
		config:         config,
		executorCtx:    executorCtx,
		executorCancel: executorCancel,
		semaphore:      make(chan struct{}, config.MaxConcurrent),
	}
}

// ========== å…¬å¼€APIæ–¹æ³• ==========
func (f *TaskFramework) SetGenerateTasksFunc(ctx context.Context, fn GenerateTasksFunc) {
	f.generateMu.Lock()
	defer f.generateMu.Unlock()
	f.generateTasksFunc = fn
}

// ========== ä¿®æ”¹ï¼šAddTasks è¿”å›å¤±è´¥çš„ä»»åŠ¡åˆ—è¡¨ ==========
// AddTasks æ‰¹é‡æ·»åŠ ä»»åŠ¡
// ctx: ç”¨äºç³»ç»Ÿè®°å½•
// tasks: å¾…æ·»åŠ çš„ä»»åŠ¡åˆ—è¡¨
// executeFunc: ä»»åŠ¡æ‰§è¡Œå‡½æ•°
// è¿”å›:
//
//	successCount: æˆåŠŸæ·»åŠ çš„ä»»åŠ¡æ•°é‡
//	failedTasks: å¤±è´¥çš„ä»»åŠ¡åˆ—è¡¨ï¼ˆæ¯ä¸ªä»»åŠ¡çš„ FailReason å­—æ®µä¼šå¡«å……å¤±è´¥åŸå› ï¼‰
func (f *TaskFramework) AddTasks(ctx context.Context, tasks []*Task, executeFunc func(ctx context.Context, task *Task) (bool, error)) (successCount int, failedTasks []*Task) {
	// ğŸ”§ ä¿®æ”¹ï¼šä¸å†è¿”å› errorï¼Œè€Œæ˜¯è¿”å›å¤±è´¥çš„ä»»åŠ¡åˆ—è¡¨

	if executeFunc == nil {
		// å¦‚æœæ‰§è¡Œå‡½æ•°ä¸ºnilï¼Œæ‰€æœ‰ä»»åŠ¡éƒ½å¤±è´¥
		for _, task := range tasks {
			task.FailReason = "executeFunc cannot be nil"
			failedTasks = append(failedTasks, task)
		}
		return 0, failedTasks
	}

	if len(tasks) == 0 {
		return 0, nil
	}

	f.configMu.RLock()
	mode := f.config.Mode
	f.configMu.RUnlock()

	f.tasksMu.Lock()
	defer f.tasksMu.Unlock()

	f.forbiddenMu.RLock()
	defer f.forbiddenMu.RUnlock()

	// ğŸ”§ ä¿®æ”¹ï¼šæ”¶é›†å¤±è´¥çš„ä»»åŠ¡è€Œä¸æ˜¯é”™è¯¯å­—ç¬¦ä¸²
	for _, task := range tasks {
		if task.Key == "" {
			task.FailReason = "task key cannot be empty"
			failedTasks = append(failedTasks, task)
			continue
		}
		if _, forbidden := f.forbiddenKeys[task.Key]; forbidden {
			task.FailReason = fmt.Sprintf("task %s is forbidden", task.Key)
			failedTasks = append(failedTasks, task)
			continue
		}
		if _, exists := f.tasks[task.Key]; exists {
			task.FailReason = fmt.Sprintf("task %s already exists", task.Key)
			failedTasks = append(failedTasks, task)
			continue
		}

		// æˆåŠŸæ·»åŠ çš„ä»»åŠ¡
		task.executeFunc = executeFunc
		task.SuccessCount = 0
		task.FailCount = 0
		task.State = TaskStatePending
		task.Result = ""
		task.SuccessTime = nil
		task.FailTime = nil
		task.FailReason = ""
		task.StartTime = nil

		switch mode {
		case AddTaskModeRecursive:
			now := time.Now()
			task.State = TaskStateRunning
			task.StartTime = &now
			f.tasks[task.Key] = task

			successCount++
			f.wg.Add(1)
			go f.executeTask(ctx, task)

		case AddTaskModeExternal:
			f.tasks[task.Key] = task
			f.pendingTasks[task.Key] = struct{}{}
			successCount++

		default:
			task.FailReason = fmt.Sprintf("invalid mode for task %s", task.Key)
			failedTasks = append(failedTasks, task)
		}
	}

	return successCount, failedTasks
}

func (f *TaskFramework) AddForbiddenKeys(ctx context.Context, keys ...string) {
	f.forbiddenMu.Lock()
	defer f.forbiddenMu.Unlock()
	for _, key := range keys {
		if key == "" {
			continue
		}
		f.forbiddenKeys[key] = struct{}{}
	}
}

func (f *TaskFramework) RemoveForbiddenKeys(ctx context.Context, keys ...string) {
	f.forbiddenMu.Lock()
	defer f.forbiddenMu.Unlock()
	for _, key := range keys {
		delete(f.forbiddenKeys, key)
	}
}

// ========== å†…éƒ¨æ–¹æ³•ï¼ˆä¿æŒä¸å˜ï¼‰ ==========
func (f *TaskFramework) updateTaskState(ctx context.Context, task *Task, newState TaskState) {
	if task == nil {
		return
	}
	oldState := task.State
	if oldState == newState {
		return
	}

	switch oldState {
	case TaskStatePending:
		delete(f.pendingTasks, task.Key)
	case TaskStateCompleted:
		delete(f.completedTasks, task.Key)
	}

	task.State = newState

	switch newState {
	case TaskStatePending:
		f.pendingTasks[task.Key] = struct{}{}
	case TaskStateCompleted:
		f.completedTasks[task.Key] = struct{}{}
	}
}

func (f *TaskFramework) executeTask(ctx context.Context, task *Task) {
	defer f.wg.Done()

	defer func() {
		if r := recover(); r != nil {
			f.tasksMu.Lock()
			defer f.tasksMu.Unlock()

			now := time.Now()
			f.updateTaskState(ctx, task, TaskStateCompleted)
			task.Result = TaskResultFail
			task.FailTime = &now
			task.FailReason = fmt.Sprintf("execute panic: %v\nstack: %s", r, debug.Stack())
			task.FailCount++
		}
	}()

	f.configMu.RLock()
	maxTimeout := f.config.MaxTimeout
	mode := f.config.Mode
	checkInterval := f.config.CheckInterval
	f.configMu.RUnlock()

	select {
	case f.semaphore <- struct{}{}:
		defer func() { <-f.semaphore }()
	case <-f.executorCtx.Done():
		return
	}

	taskCtx, cancel := context.WithTimeout(f.executorCtx, maxTimeout)
	defer cancel()

	resultChan := make(chan struct {
		success bool
		err     error
	}, 1)

	go func() {
		defer func() {
			if r := recover(); r != nil {
				resultChan <- struct {
					success bool
					err     error
				}{
					success: false,
					err:     fmt.Errorf("executeFunc panic: %v\nstack: %s", r, debug.Stack()),
				}
			}
		}()
		success, err := task.executeFunc(taskCtx, task)
		resultChan <- struct {
			success bool
			err     error
		}{success, err}
	}()

	select {
	case <-f.executorCtx.Done():
		f.tasksMu.Lock()
		now := time.Now()
		f.updateTaskState(ctx, task, TaskStateCompleted)
		task.Result = TaskResultFail
		task.FailTime = &now
		task.FailReason = "framework stopped"
		task.FailCount++
		f.tasksMu.Unlock()
		return

	case <-taskCtx.Done():
		f.tasksMu.Lock()
		now := time.Now()
		f.updateTaskState(ctx, task, TaskStateCompleted)
		task.Result = TaskResultFail
		task.FailTime = &now
		task.FailReason = fmt.Sprintf("timeout after %v: %v", maxTimeout, taskCtx.Err())
		task.FailCount++
		f.tasksMu.Unlock()
		return

	case res := <-resultChan:
		f.tasksMu.Lock()
		now := time.Now()

		if res.success {
			task.Result = TaskResultOK
			task.SuccessTime = &now
			task.SuccessCount++

			var needGenerate bool
			var generateFunc GenerateTasksFunc
			var cycleStart time.Time
			var taskCopyForGenerate *Task

			if mode == AddTaskModeRecursive {
				f.updateTaskState(ctx, task, TaskStatePending)
				f.generateMu.RLock()
				generateFunc = f.generateTasksFunc
				f.generateMu.RUnlock()

				f.cycleMu.RLock()
				cycleStart = f.currentCycleStart
				f.cycleMu.RUnlock()

				if !cycleStart.IsZero() && generateFunc != nil {
					needGenerate = now.After(cycleStart) && now.Before(cycleStart.Add(checkInterval))
				}
				if needGenerate {
					taskCopyForGenerate = &Task{
						Key:         task.Key,
						Data:        task.Data,
						Result:      task.Result,
						SuccessTime: task.SuccessTime,
						executeFunc: task.executeFunc,
					}
				}
			} else {
				f.updateTaskState(ctx, task, TaskStateCompleted)
			}

			f.tasksMu.Unlock()

			if needGenerate && mode == AddTaskModeRecursive && generateFunc != nil && taskCopyForGenerate != nil {
				go func() {
					defer func() {
						_ = recover()
					}()
					newTasks := generateFunc(taskCopyForGenerate)
					_, _ = f.AddTasks(ctx, newTasks, taskCopyForGenerate.executeFunc)
				}()
			}
			return
		} else {
			f.updateTaskState(ctx, task, TaskStateCompleted)
			task.Result = TaskResultFail
			task.FailTime = &now
			task.FailReason = res.err.Error()
			task.FailCount++
		}

		f.tasksMu.Unlock()
	}
}

func (f *TaskFramework) cycleExecutor(ctx context.Context) {
	f.triggerCycle(ctx)

	f.configMu.RLock()
	cycleInterval := f.config.CycleInterval
	f.configMu.RUnlock()

	cycleTicker := time.NewTicker(cycleInterval)
	defer cycleTicker.Stop()

	for {
		select {
		case <-f.executorCtx.Done():
			return
		case <-cycleTicker.C:
			f.triggerCycle(ctx)
		}
	}
}

func (f *TaskFramework) triggerCycle(ctx context.Context) {
	now := time.Now()
	f.cycleMu.Lock()
	f.currentCycleStart = now
	f.cycleMu.Unlock()

	f.configMu.RLock()
	checkInterval := f.config.CheckInterval
	f.configMu.RUnlock()

	f.tasksMu.RLock()
	taskKeysToRun := make([]string, 0, len(f.pendingTasks)+len(f.completedTasks))
	for key := range f.pendingTasks {
		taskKeysToRun = append(taskKeysToRun, key)
	}
	for key := range f.completedTasks {
		taskKeysToRun = append(taskKeysToRun, key)
	}
	f.tasksMu.RUnlock()

	for _, key := range taskKeysToRun {
		f.forbiddenMu.RLock()
		_, forbidden := f.forbiddenKeys[key]
		f.forbiddenMu.RUnlock()
		if forbidden {
			continue
		}

		f.tasksMu.Lock()
		task, exists := f.tasks[key]
		if !exists || (task.State != TaskStatePending && task.State != TaskStateCompleted) {
			f.tasksMu.Unlock()
			continue
		}
		f.updateTaskState(ctx, task, TaskStateRunning)
		task.StartTime = &now
		f.tasksMu.Unlock()

		f.wg.Add(1)
		go f.executeTask(ctx, task)
	}

	go func() {
		time.Sleep(checkInterval)
		f.triggerCheck(ctx)
	}()
}

func (f *TaskFramework) triggerCheck(ctx context.Context) {
	f.configMu.RLock()
	mode := f.config.Mode
	checkInterval := f.config.CheckInterval
	f.configMu.RUnlock()

	f.generateMu.RLock()
	generateFunc := f.generateTasksFunc
	f.generateMu.RUnlock()

	if mode != AddTaskModeRecursive || generateFunc == nil {
		return
	}

	f.cycleMu.RLock()
	cycleStart := f.currentCycleStart
	f.cycleMu.RUnlock()
	if cycleStart.IsZero() {
		return
	}

	f.tasksMu.RLock()
	tasksToCheck := make([]*Task, 0)
	for key := range f.completedTasks {
		task := f.tasks[key]
		if task.Result == TaskResultOK {
			tasksToCheck = append(tasksToCheck, task)
		}
	}
	f.tasksMu.RUnlock()

	for _, task := range tasksToCheck {
		f.tasksMu.RLock()
		completeTime := task.SuccessTime
		currentTask, exists := f.tasks[task.Key]
		executeFunc := task.executeFunc
		f.tasksMu.RUnlock()

		if !exists || completeTime == nil {
			continue
		}
		if !completeTime.After(cycleStart) || !completeTime.Before(cycleStart.Add(checkInterval)) {
			continue
		}

		go func(t *Task) {
			defer func() {
				_ = recover()
			}()
			newTasks := generateFunc(t)
			_, _ = f.AddTasks(ctx, newTasks, executeFunc)
		}(currentTask)
	}
}

func (f *TaskFramework) Start(ctx context.Context) {
	f.configMu.RLock()
	config := *f.config
	f.configMu.RUnlock()

	go f.cycleExecutor(ctx)
	fmt.Printf("task framework started, config: mode=%d, cycle=%v, check=%v, timeout=%v, max_concurrent=%d\n",
		config.Mode, config.CycleInterval, config.CheckInterval, config.MaxTimeout, config.MaxConcurrent)
}

func (f *TaskFramework) Stop(ctx context.Context) {
	f.executorCancel()
	f.wg.Wait()
	fmt.Println("task framework stopped gracefully")
}
