package main

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/cpusoft/goutil/belogs"
	"github.com/cpusoft/goutil/jsonutil"
	"github.com/cpusoft/goutil/taskcycleutil"
)

// ========== 下载任务配置 ==========
// DownloadTaskConfig 下载任务的自定义参数
type DownloadTaskConfig struct {
	URLs       []string `json:"urls"`       // 待下载的URL数组
	SaveDir    string   `json:"saveDir"`    // 文件保存目录
	Timeout    int      `json:"timeout"`    // 单个URL下载超时（秒）
	RetryCount int      `json:"retryCount"` // 重试次数
}

// ========== 核心下载函数 ==========
// downloadFile 单个URL下载实现
func downloadFile(ctx context.Context, url, saveDir string, timeout int) (string, error) {
	// 创建保存目录
	if err := os.MkdirAll(saveDir, 0755); err != nil {
		return "", fmt.Errorf("create save dir failed: %w", err)
	}

	// 设置HTTP客户端超时
	client := &http.Client{
		Timeout: time.Duration(timeout) * time.Second,
	}

	// 发起HTTP请求
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return "", fmt.Errorf("create request failed: %w", err)
	}

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// 检查响应状态
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("invalid status code: %d", resp.StatusCode)
	}

	// 生成保存文件名（基于URL和时间戳）
	fileName := fmt.Sprintf("%s_%d%s",
		filepath.Base(url),
		time.Now().UnixNano(),
		filepath.Ext(url),
	)
	savePath := filepath.Join(saveDir, fileName)

	// 创建文件并写入内容
	file, err := os.Create(savePath)
	if err != nil {
		return "", fmt.Errorf("create file failed: %w", err)
	}
	defer file.Close()

	// 拷贝响应内容到文件
	_, err = io.Copy(file, resp.Body)
	if err != nil {
		return "", fmt.Errorf("write file failed: %w", err)
	}

	return savePath, nil
}

// ========== 框架执行函数适配 ==========
// downloadTaskExecuteFunc 适配框架的执行函数
// 功能：遍历URL数组，逐个下载，全部成功则返回true，否则返回false
func downloadTaskExecuteFunc(ctx context.Context, task *taskcycleutil.Task) (bool, error) {
	// 解析自定义任务数据
	var downloadConfig DownloadTaskConfig
	// 这里假设你使用jsonutil反序列化（也可自定义解析方式）
	// 注：实际使用时需确保task.Data.Content是JSON格式的DownloadTaskConfig
	if err := jsonutil.UnmarshalJson(task.Data.Content, &downloadConfig); err != nil {
		return false, fmt.Errorf("parse download config failed: %w", err)
	}

	// 校验配置
	if len(downloadConfig.URLs) == 0 {
		return false, errors.New("empty urls list")
	}
	if downloadConfig.SaveDir == "" {
		downloadConfig.SaveDir = "./downloads" // 默认保存目录
	}
	if downloadConfig.Timeout <= 0 {
		downloadConfig.Timeout = 30 // 默认30秒超时
	}
	if downloadConfig.RetryCount < 0 {
		downloadConfig.RetryCount = 2 // 默认重试2次
	}

	// 遍历URL执行下载（带重试）
	successCount := 0
	failedURLs := make([]string, 0)

	for _, url := range downloadConfig.URLs {
		var savePath string
		var err error

		// 重试逻辑
		for i := 0; i <= downloadConfig.RetryCount; i++ {
			savePath, err = downloadFile(ctx, url, downloadConfig.SaveDir, downloadConfig.Timeout)
			if err == nil {
				belogs.Info(fmt.Sprintf("download success: %s -> %s (retry: %d)", url, savePath, i))
				successCount++
				break
			}
			belogs.Warn(fmt.Sprintf("download failed: %s (retry: %d): %v", url, i, err))

			// 最后一次重试失败，记录失败URL
			if i == downloadConfig.RetryCount {
				failedURLs = append(failedURLs, url)
			}

			// 非最后一次重试，等待1秒后重试
			if i < downloadConfig.RetryCount {
				time.Sleep(1 * time.Second)
			}
		}
	}

	// 全部URL下载成功则返回true，否则返回false
	if len(failedURLs) == 0 {
		return true, nil
	}

	return false, fmt.Errorf("download failed for urls: %v (success: %d/%d)",
		failedURLs, successCount, len(downloadConfig.URLs))
}

// ========== 递归生成新任务函数（可选） ==========
// generateNewDownloadTasks 从成功的下载任务生成新任务（示例：下载关联文件）
// 注：仅在AddTaskModeRecursive模式下生效
func generateNewDownloadTasks(completedTask *taskcycleutil.Task) []*taskcycleutil.Task {
	// 示例逻辑：从已下载文件的URL生成新的下载任务（可自定义业务逻辑）
	// 这里简化处理：生成一个空任务（实际需根据业务场景扩展）
	newTask := &taskcycleutil.Task{
		Key: fmt.Sprintf("download_task_%s_%d", completedTask.Key, time.Now().UnixNano()),
		Data: taskcycleutil.TaskData{
			Content: `{"urls":["https://example.com/关联文件.txt"], "saveDir":"./downloads关联"}`,
		},
	}
	return []*taskcycleutil.Task{newTask}
}

// ========== 主函数：框架使用示例 ==========
func main() {
	// ========== 1. 初始化框架配置 ==========
	// 选择模式：
	// - AddTaskModeRecursive：递归模式（从成功任务生成新任务）
	// - AddTaskModeExternal：外部模式（仅外部添加任务，待周期执行）
	mode := taskcycleutil.AddTaskModeExternal
	config := taskcycleutil.NewConfig(mode)
	// 可自定义配置（默认30分钟周期、70分钟超时）
	config.CycleInterval = 30 * time.Minute
	config.MaxTimeout = 70 * time.Minute
	config.CheckInterval = 10 * time.Minute

	// ========== 2. 创建框架实例 ==========
	framework, err := taskcycleutil.NewTaskFramework(config)
	if err != nil {
		belogs.Error("create task framework failed: ", err)
		os.Exit(1)
	}
	defer framework.Stop() // 程序退出时停止框架

	// ========== 3. （可选）设置递归生成任务函数（仅递归模式需要） ==========
	if mode == taskcycleutil.AddTaskModeRecursive {
		framework.SetGenerateTasksFunc(generateNewDownloadTasks)
	}

	// ========== 4. 添加禁止执行的URL/任务Key（可选） ==========
	// 示例：禁止下载特定域名的任务
	forbiddenKeys := []string{
		"download_task_forbidden_1", // 任务Key
	}
	framework.AddForbiddenKeys(forbiddenKeys...)

	// ========== 5. 构建下载任务列表 ==========
	// 待下载的URL数组
	downloadURLs := []string{
		"https://example.com/file1.txt",
		"https://example.com/file2.jpg",
		"https://example.com/file3.pdf",
	}

	// 构建自定义下载配置
	downloadConfig := DownloadTaskConfig{
		URLs:       downloadURLs,
		SaveDir:    "./downloads",
		Timeout:    30,
		RetryCount: 2,
	}

	// 序列化配置为JSON（存入task.Data.Content）
	configJson := jsonutil.MarshalJson(downloadConfig)

	// 构建框架任务
	tasks := []*taskcycleutil.Task{
		{
			Key: "download_task_1", // 任务唯一Key
			Data: taskcycleutil.TaskData{
				Content: configJson, // 自定义数据（JSON格式的下载配置）
				Params: map[string]interface{}{
					"description": "测试下载任务",
					"priority":    "high",
				},
			},
		},
		// 可添加更多任务...
		// {
		// 	Key: "download_task_2",
		// 	Data: taskcycleutil.TaskData{
		// 		Content: `{"urls":["https://example.com/file4.zip"], "saveDir":"./downloads"}`,
		// 	},
		// },
	}

	// ========== 6. 启动框架 ==========
	framework.Start()
	belogs.Info("task framework started, waiting for cycle execution...")

	// ========== 7. 批量添加任务 ==========
	successCount, failedTasks := framework.AddTasks(tasks, downloadTaskExecuteFunc)
	belogs.Info(fmt.Sprintf("add tasks result: success=%d, failed=%d", successCount, len(failedTasks)))

	// 打印失败任务信息
	if len(failedTasks) > 0 {
		for _, task := range failedTasks {
			belogs.Error(fmt.Sprintf("add task failed: %s, reason: %s", task.Key, task.FailReason))
		}
	}

	// ========== 8. 保持程序运行 ==========
	// 示例：运行1小时后退出
	runDuration := 1 * time.Hour
	belogs.Info(fmt.Sprintf("framework will run for %v, press Ctrl+C to exit", runDuration))
	time.Sleep(runDuration)

	// ========== 9. 停止框架 ==========
	framework.Stop()
	belogs.Info("task framework stopped")

	// ========== 10. 输出任务执行结果（可选） ==========
	framework.TasksMu.RLock() // 注：需将框架的tasksMu改为导出字段，或添加获取任务的方法
	defer framework.TasksMu.RUnlock()

	for key, task := range framework.Tasks {
		belogs.Info(fmt.Sprintf("task %s result: %s, success count: %d, fail count: %d",
			key, task.Result, task.SuccessCount, task.FailCount))
	}
}
